#define QCWEAPONANIMATION_ORIGIN(e) (sv_qcweaponanimation ?  ((weapon_offset_x + e.view_ofs_x) * v_forward - (weapon_offset_y + e.view_ofs_y) * v_right + (weapon_offset_z + e.view_ofs_z) * v_up + weapon_adjust) : e.view_ofs)

float g_balance_weaponswitchdelay;
float g_projectiles_newton_style;
float g_projectiles_newton_style_2_maxfactor;
float g_projectiles_newton_style_2_minfactor;
float g_weaponratefactor;
float g_weapon_throw_mode;
float g_weapon_throw_noammo;
float g_weapon_pickup_no_ammo;
float g_weapon_thrown_lifetime;
float g_showweaponspawns;
vector sv_qcanimation_melee_morph1angles;
vector sv_qcanimation_melee_morph2angles;
vector sv_qcanimation_melee_morph1origin;
vector sv_qcanimation_melee_morph2origin;
vector sv_qcanimation_melee2_morph1angles;
vector sv_qcanimation_melee2_morph2angles;
vector sv_qcanimation_melee2_morph1origin;
vector sv_qcanimation_melee2_morph2origin;
vector sv_qcanimation_melee_exterior;
float sv_qcweaponanimation;
float g_shootfromcenter;
float g_shootfromeye;
float g_shootforward;
float g_norecoil;
float g_recoil_extra;
float g_recoil_extra_crouch_factor;
float g_recoil_extra_fly_factor;
float g_recoil_extra_spread;
float g_recoil_extra_spread_crouch_factor;
float g_recoil_extra_spread_fly_factor;
float sv_debug_weapon_tags;

vector weapon_offset = '0 -10 0';
vector weapon_adjust = '10 0 -15';

.vector weapon_morph0origin;
.vector weapon_morph0angles;
.float  weapon_morph0time;
.vector weapon_morph1origin;
.vector weapon_morph1angles;
.float  weapon_morph1time;
.vector weapon_morph2origin;
.vector weapon_morph2angles;
.float  weapon_morph2time;
.vector weapon_morph3origin;
.vector weapon_morph3angles;
.float  weapon_morph3time;
.vector weapon_morph4origin;
.vector weapon_morph4angles;
.float  weapon_morph4time;

float(float w) weapon_ammo_check {
	entity e = weapon_info(w);
	if (e.ammo_rockets) {
		if (e.items & IT_SHELLS) {
			return e.ammo_rockets <= self.ammo_shells;
		} else if (e.items & IT_CELLS) {
			return e.ammo_rockets <= self.ammo_cells;
		} else if (e.items & IT_ROCKETS) {
			return e.ammo_rockets <= self.ammo_rockets;
		} else if (e.items & IT_NAILS) {
			return e.ammo_rockets <= self.ammo_nails;
		}
		return FALSE;
	}
	return TRUE;
}

float(float w, float secondary) weapon_ammo_check_secondary {
	entity e = weapon_info(w);
	if (secondary) {
		if (e.ammo_nails) {
			if (e.items & IT_SHELLS) {
				return e.ammo_nails <= self.ammo_shells;
			} else if (e.items & IT_CELLS) {
				return e.ammo_nails <= self.ammo_cells;
			} else if (e.items & IT_ROCKETS) {
				return e.ammo_nails <= self.ammo_rockets;
			} else if (e.items & IT_NAILS) {
				return e.ammo_nails <= self.ammo_nails;
			}
		}
	} else {
		if (e.ammo_shells) {
			if (e.items & IT_SHELLS) {
				return e.ammo_shells <= self.ammo_shells;
			} else if (e.items & IT_CELLS) {
				return e.ammo_shells <= self.ammo_cells;
			} else if (e.items & IT_ROCKETS) {
				return e.ammo_shells <= self.ammo_rockets;
			} else if (e.items & IT_NAILS) {
				return e.ammo_shells <= self.ammo_nails;
			}
		}
	}
	return TRUE;
}

void(float w, float a1, float a2) weapon_ammo_limits {
	entity e = weapon_info(w);
	e.ammo_shells = a1; //primary
	e.ammo_nails = a2; //secondary
	if not(a1)
		e.ammo_rockets = a2;
	else if not(a2)
		e.ammo_rockets = a1;
	else
		e.ammo_rockets = min(a1, a2); //required minimum
}

float(entity e, string s) weapon_gettagindex {
	float t = gettagindex(e, s);
	if not(t)
		t = gettagindex(e, strcat("tag_", s));

	return t;
}

void(entity e1, entity e2, string s) weapon_setattachment {
	setattachment(e1, e2, s);
	if not(e1.tag_index)
		setattachment(e1, e2, strcat("tag_", s));
}

void(void) weapon_reload {
	if not(plugin_ReloadAllowed())
		return;

	if (self.switchweapon == self.weapon)
	if (self.weaponentity.state == WEAPON_STATE_READY) {
		weapon_action(self.weapon, WEAPON_REQUEST_RELOAD);
	}
	if (weapon_melee_possible(TRUE))
		weapon_melee_attack_check();

	akimbo_reload(self);
}

void(entity pl) weapon_show_list {
	if (clienttype(pl) == CLIENTTYPE_REAL) {
		msg_entity = pl;
		net_write_byte(MSG_ONE, SVC_TEMPENTITY);
		net_write_byte(MSG_ONE, NET_TE_CSQC_WEAPONLIST);
	}
	entity e;
	CLIENT_FOR_EACH_REAL(e) {
		if (e.enemy == pl)
		if (e.classname == "spectator") {
			msg_entity = e;
			net_write_byte(MSG_ONE, SVC_TEMPENTITY);
			net_write_byte(MSG_ONE, NET_TE_CSQC_WEAPONLIST);
		}
	}
}

void(entity e, float w) weapon_switch_force {
	weapon_show_list(self);
	if (e.switchweapon && w && w != e.switchweapon)
		e.cnt = e.switchweapon;

	e.switchweapon = w;
}

// switch between weapons
void(float imp) weapon_switch {
	if (self.switchweapon != imp) {
		if (weapon_carried(self, imp, !g_weapon_switch_to_empty, TRUE))
			weapon_switch_force(self, imp);
		else
			weapon_show_list(self);
	}
};

.float weaponcomplainindex;
float(entity pl, string weaponorder, float dir, float imp, float complain) weaypon_cycle_get {
	float n, i, weaponwant, first_valid, prev_valid, switchtonext, switchtolast, c;
	entity wi;
	n = tokenize_console(weaponorder);
	switchtonext = switchtolast = 0;
	first_valid = prev_valid = 0;
	if (dir == 0)
		switchtonext = 1;

	c = 0;
	for (i = 0; i < n; ++i) {
		weaponwant = stof(argv(i));
		wi = weapon_info(weaponwant);
		if (imp >= 0)
			if (wi.impulse != imp)
				continue;

		if not(wi.weapons & weapon_spawned_list)
		if not(wi.weapons_extra & weapon_spawned_extra_list)
		if not(wi.weapons & pl.weapons)
		if not(wi.weapons_extra & pl.weapons_extra)
			continue;

		++c;
		if (weapon_carried(pl, weaponwant, !g_weapon_switch_to_empty, FALSE)) {
			if (switchtonext)
				return weaponwant;

			if (!first_valid)
				first_valid = weaponwant;

			if (weaponwant == pl.switchweapon) {
				if (dir >= 0)
					switchtonext = 1;
				else if (prev_valid)
					return prev_valid;
				else
					switchtolast = 1;
			}
			prev_valid = weaponwant;
		}
	}
	// complain (but only for one weapon on the button that has been pressed)
	if (complain) {
		weapon_show_list(pl);
		self.weaponcomplainindex += 1;
		if (c)
			c = math_mod(self.weaponcomplainindex, c) + 1;

		for (i = 0; i < n; ++i) {
			weaponwant = stof(argv(i));
			wi = weapon_info(weaponwant);
			if (imp >= 0) {
				if (wi.impulse != imp)
					continue;
			}
			if not(wi.weapons & weapon_spawned_list)
			if not(wi.weapons_extra & weapon_spawned_extra_list)
			if not(wi.weapons & pl.weapons)
			if not(wi.weapons_extra & pl.weapons_extra)
				continue;

			--c;
			if (c <= 0) {
				weapon_carried(pl, weaponwant, !g_weapon_switch_to_empty, TRUE);
				break;
			}
		}
	}
	if (first_valid) {
		if (switchtolast)
			return prev_valid;
		else
			return first_valid;
	}
	return 0;
}

void(string weaponorder, float dir) weapon_cycle {
	float w;
	w = weaypon_cycle_get(self, weaponorder, dir, -1, 0);
	if (w > 0)
		weapon_switch(w);
}

void(float imp) weapon_next_on_impulse {
	float w;
	w = weaypon_cycle_get(self, self.cvar_cl_weaponpriority, +1, imp, 1);
	if (w > 0)
		weapon_switch(w);
}

// next weapon
void(float list) weapon_next {
	if (list == 0)
		weapon_cycle(weapon_priority_by_order, -1);
	else if (list == 1)
		weapon_cycle(weapon_priority_by_impulse, -1);
	else if (list == 2)
		weapon_cycle(self.cvar_cl_weaponpriority, -1);
}

// prev weapon
void(float list) weapon_previous {
	if (list == 0)
		weapon_cycle(weapon_priority_by_order, +1);
	else if (list == 1)
		weapon_cycle(weapon_priority_by_impulse, +1);
	else if ( list == 2)
		weapon_cycle(self.cvar_cl_weaponpriority, +1);
}

string weapon_fix_order_allow_incomplete(string order) {
	return weapon_fix_order(order, 0);
}

string weapon_fix_order_force_complete(string order) {
	if (order == "")
		order = cvar_string("cl_weaponpriority");

	return weapon_fix_order(order, 1);
}

float(entity e) weapon_best {
	return weaypon_cycle_get(e, e.cvar_cl_weaponpriority, 0, -1, 0);
}

// generic weapons table
// TODO should they be macros instead?
float(float wpn, float wrequest) weapon_action {
	float w = self.weapon;
	self.weapon = wpn;
	float r = (weapon_info(wpn)).weapon_func(wrequest);
	self.weapon = w;
	return r;
}

string(float weaponid) weapon_name {
	return (weapon_info(weaponid)).message;
}

float(float wpn) weapon_ammo_item_code {
	return (weapon_info(wpn)).items;
}

void(void) weapon_thrown_think {
	self.solid = SOLID_TRIGGER;
	self.owner = NULL;
	entity_fade_setup(self, time + g_weapon_thrown_lifetime, 1);
}

// returns amount of ammo used as string, or -1 for failure, or 0 for no ammo count
vector(entity own, float wpn, float doreduce, vector org, vector velo) weapon_throw_new {
	entity oldself, wep;
	float wa, thisammo, i;
	var .float ammofield;
	wep = spawn();
	setorigin(wep, org);
	wep.classname = "droppedweapon";
	wep.velocity = velo;
	wep.owner = wep.enemy = own;
	wep.colormap = own.colormap;
	wa = weapon_ammo_item_code(wpn);
	oldself = self;
	self = wep;
	weapon_defaultspawnfunc(wpn);
	self = oldself;
	if (item_start_failed)
		return '-1 0 0';

	entity_move_out_of_solid_with_type(wep, TRACE_MOVE_NORMAL);
	wep.think = weapon_thrown_think;
	wep.nextthink = time + 0.5;
	if (wa == IT_SUPERWEAPON || (wa == 0 && !g_weapon_throw_noammo)) { //probably this code not needed
		return '0 0 0';
	}
	thisammo = 0;
	if (doreduce || g_weapon_throw_mode) {
		ammofield = item_counter_field(wa);
		if (ammofield) {
			thisammo = min(own.ammofield, wep.ammofield);
			if (thisammo <= 0)
				thisammo = own.ammofield;

			wep.ammofield = thisammo;
			own.ammofield -= thisammo;
		}
	}
	return wa * '1 0 0' + thisammo * '0 1 0';
}

float(float w) weapon_throwable {
	float wa;
	entity wi = weapon_info(w);
	if not(wi.weapons)
	if not(wi.weapons_extra)
		return 0;

	wa = weapon_ammo_item_code(w);
	if ((player_start_weapons & wi.weapons) || (player_start_weapons_extra & wi.weapons_extra)) {
		if (wa == IT_SUPERWEAPON && (player_start_items & IT_UNLIMITED_SUPERWEAPONS))
			return 0;

		if (wa != IT_SUPERWEAPON && (player_start_items & IT_UNLIMITED_WEAPON_AMMO))
			return 0;

		// start weapons that take no ammo can't be dropped (this prevents dropping the laser, as long as it continues to use no ammo)
		if (wa == 0 && !g_weapon_throw_noammo)
			return 0;
	}
	return 1;
}

// toss current weapon
void(vector velo, float doreduce) weapon_throw {
	float w;
	entity wi;
	vector a;
	w = self.weapon;
	if (w == 0)
		return; // just in case

	if not(plugin_chain_weapon_throw_allowed(doreduce))
		return;

	if (g_pickup_nodrop)
		return;

	if (doreduce && g_weapon_stay == 1) //prevent ammo multiplication
		return;

	wi = weapon_info(w);
	float akimbo_throw = akimbo_weapon_throw(w);
	if not(akimbo_throw) {
		if not(g_pickup_items)
			return;

		if not(g_pickup_weapons)
			return;

		if (!weapon_throwable(w))
			return;
	}
	if not(self.weapons & wi.weapons)
	if not(self.weapons_extra & wi.weapons_extra)
		return;

	if not(akimbo_throw) {
		self.weapons &= ~wi.weapons;
		self.weapons_extra &= ~wi.weapons_extra;
		weapon_switch_force(self, weapon_best(self));
	}
	a = weapon_throw_new(self, w, doreduce, ENTITY_CENTER(self), velo);
	if (a_x < 0)
		return;

	if (self.health >= 1) {
		if (clienttype(self) == CLIENTTYPE_REAL) {
			if not(a_x)
				print_to(self, PRINT_INFO, "You dropped the ^2{1}", weapon_name(w), "", "");
			else
				print_to(self, PRINT_INFO, "You dropped the ^2{1} with {2} {3}", weapon_name(w), ftos(a_y), item_counter_field_name(a_x));
		}
	}
}

.float hasweapon_complain_spam;
float(entity cl, float wpn, float andammo, float complain) weapon_carried {
	float f;
	entity wi;
	entity oldself;
	if (time < cl.hasweapon_complain_spam)
		complain = 0;

	if (complain)
		cl.hasweapon_complain_spam = time + 0.2;

	wi = weapon_info(wpn);
	if not(wi.weapon) {
		if (complain) {
			if (clienttype(cl) == CLIENTTYPE_REAL)
				print_to(cl, PRINT_INFO, "Invalid weapon", "", "", "");
		}
		return FALSE;
	}
	if ((cl.weapons & wi.weapons) || (cl.weapons_extra & wi.weapons_extra)) {
		if (andammo) {
			if (cl.items & IT_UNLIMITED_WEAPON_AMMO) {
				f = 1;
			} else {
				oldself = self;
				self = cl;
				f = weapon_ammo_check(wpn);
				self = oldself;
			}
			if (!f) {
				if (complain)
				if (clienttype(cl) == CLIENTTYPE_REAL) {
					sound_play2(cl, "weapons/unavailable.wav");
					print_to(cl, PRINT_INFO, "You don't have any ammo for the ^2{1}", weapon_name(wpn), "", "");
				}
				return FALSE;
			}
		}
		return TRUE;
	}
	if (complain)
	if (clienttype(cl) == CLIENTTYPE_REAL) {
		if ((weapon_spawned_list & wi.weapons) || (weapon_spawned_extra_list & wi.weapons_extra)) {
			print_to(cl, PRINT_INFO, "You do not have the ^2{1}", weapon_name(wpn), "", "");
			if (g_showweaponspawns)
			if (self.client_flags & CLIENT_FLAG_SHOWWEAPONS) {
				entity e;
				string s;
				s = wi.model2;
				for (e = weapon_spawn_chain; e; e = e.enemy) {
					if (!e.weapons || e.weapons != wi.weapons)
					if (!e.weapons_extra || e.weapons_extra != wi.weapons_extra)
						continue;

					marker_Spawn(
						s,
						1, 0,
						world, e.origin,
						cl, 0,
						world, enemy,
						0
					);
				}
			}
		} else
			print_to(cl, PRINT_INFO, "Requested weapon is ^1NOT AVAILABLE^7 in this map", "", "", "");

		sound_play2(cl, "weapons/unavailable.wav");
	}
	return FALSE;
}

// Bringed back weapon frame
void(void) weapon_frame {
	vector fo, ri, up;
	self.ammoclip = 0;
	makevectors(self.v_angle);
	if (plugin_chain_weapon_frame_handle())
		return;

	if (!self.weaponentity || self.health < 1)
		return; // Dead player can't use weapons and injure impulse commands

	float _switchweapon = plugin_chain_weapon_frame_switch_mod(self.switchweapon);
	if (!self.weapon) {
		self.items &= ~IT_AMMO;
		self.weaponname = "";
	}
	fo = v_forward; // save them in case the weapon think functions change it
	ri = v_right;
	up = v_up;
	// Change weapon
	if (self.weapon != _switchweapon) {
		if (!g_balance_weaponswitchdelay) {
			float aw = akimbo_active(self);
			if (aw > 1)
			if not(akimbo_weapon_have(self, _switchweapon, aw))
				return;
			weapon_action(self.weapon, WEAPON_REQUEST_CLEAR);
			weapon_setup(_switchweapon);
			weapon_thinkf(WEAPON_FRAME_IDLE, 0, weapon_ready);
		} else if (self.weaponentity.state == WEAPON_STATE_CLEAR) {
			player_body_animation_set(self, anim_draw, FALSE, TRUE, TRUE, 1);
			self.weaponentity.state = WEAPON_STATE_RAISE;
			weapon_action(self.weapon, WEAPON_REQUEST_CLEAR);
			weapon_setup(_switchweapon);
			// VorteX: add player model weapon select frame here
			// setcustomframe(PlayerWeaponRaise);
			weapon_thinkf(WEAPON_FRAME_IDLE, g_balance_weaponswitchdelay, weapon_ready);
		} else if (self.weaponentity.state == WEAPON_STATE_READY) {
			weapon_action(self.weapon, WEAPON_REQUEST_CLEAR);
			// UGLY WORKAROUND: play this on CHAN_WEAPON2 so it can't cut off fire sounds
			sound (self, CHAN_WEAPON2, "weapons/weapon_switch.wav", VOL_BASE, ATTN_NORM);
			self.weaponentity.state = WEAPON_STATE_DROP;
			// set up weapon switch think in the future, and start drop anim
			weapon_thinkf(WEAPON_FRAME_DONTCHANGE, g_balance_weaponswitchdelay, weapon_clear);
		}
	}
	entity wi;
	if (self.weapon)
		wi = weapon_info(self.weapon);
	else
		wi = NULL;

	// call the think code which may fire the weapon
	// and do so multiple times to resolve framerate dependency issues if the
	// server framerate is very low and the weapon fire rate very high
	float i;
	for (i = 0; i < 5; i++) {
		if (wi && !(self.weapons & wi.weapons) && !(self.weapons_extra & wi.weapons_extra)) {
			if (self.weapon || self.weapons || self.weapons_extra) { //in other case there is no any weapon
				weapon_switch_force(self, weapon_best(self));
				wi = weapon_info(self.weapon);
			}
		}
		if (wi) {
			v_forward = fo;
			v_right = ri;
			v_up = up;
			weapon_action(self.weapon, WEAPON_REQUEST_THINK);
			if (self.spawnshieldtime > time)
			if (self.weaponentity.state == WEAPON_STATE_INUSE) {
				self.spawnshieldtime = time; //weapon was used, disable spawnshield
			}
		}
		if (time + frametime * 0.5 >= self.weapon_nextthink) {
			if (self.weapon_think) {
				v_forward = fo;
				v_right = ri;
				v_up = up;
				self.weapon_think();
			}
		} else
			break;
	}
}

void(float wpn) weapon_precache {
	entity e = weapon_info(wpn);
	item_precache(e.model, e.lodmodel1, "weapons/weaponpickup.wav");
	precache_model(strcat("models/weapons/v_", e.mdl, ".md3"));
	precache_model(strcat("models/weapons/h_", e.mdl, ".dpm"));
	string s = strcat("models/weapons/o_", e.mdl, ".md3");
	if (file_exists(s))
		precache_model(s);

	entity oldself = self;
	self = e;
	e.weapon_func(WEAPON_REQUEST_PRECACHE);
	self = oldself;
}

float weapon_defaultspawnfunc_internalteam;
void(float wpn) weapon_defaultspawnfunc {
	entity e;
	float t;
	var .float ammofield;
	string s;
	entity oldself;
	float i, j;
	var void() item_spawnfunc;
	if (self.classname != "droppedweapon" && self.classname != "replacedweapon") {
		e = weapon_info(wpn);
		s = cvar_string(strcat("g_weaponreplace_", e.netname));
		if (s == "0") {
			remove(self);
			item_start_failed = TRUE;
			return;
		}
		t = tokenize_console(s);
		if (t >= 2) {
			if not(self.team)
				self.team = --weapon_defaultspawnfunc_internalteam;

			oldself = self;
			for (i = 1; i < t; ++i) {
				s = argv(i);
				e = weapon_info_by_name(s);
				if (e) {
					self = spawn();
					copyentity(oldself, self);
					self.classname = "replacedweapon";
					weapon_defaultspawnfunc(e.weapon);
				} else {
					item_spawnfunc = item_spawnfunc_for(s);
					if (item_spawnfunc) {
						//print("weapon ", oldself.classname, " replaced with ", s, "\n");
						self = spawn();
						copyentity(oldself, self);
						self.classname = "replaceditem";
						item_spawnfunc();
					} else
						print("The weapon replace list for ", oldself.classname, " contains an unknown item ", s, ". Skipped.\n");
				}
			}
			self = oldself;
		}
		if (t >= 1) {
			s = argv(0);
			wpn = 0;
			e = weapon_info_by_name(s);
			if (e) {
				wpn = e.weapon;
			} else {
				item_spawnfunc = item_spawnfunc_for(s);
				if (item_spawnfunc) {
					//print("weapon ", self.classname, " replaced with ", s, "\n");
					self.classname = "replaceditem";
					item_spawnfunc();
					return;
				}
				print("The weapon replace list for ", self.classname, " contains an unknown weapon ", s, ". Skipped.\n");
			}
		}
		if (wpn == 0) {
			remove(self);
			item_start_failed = TRUE;
			return;
		}
	}
	if not(g_pickup_weapons) {
		remove(self);
		return;
	}
	if (plugin_chain_WeaponSpawnHandle(wpn))
		return;

	// set the respawntime in advance (so replaced weapons can copy it)
	if (!self.respawntime) {
		e = weapon_info(wpn);
		if (e.items == IT_SUPERWEAPON) {
			self.respawntime = g_pickup_respawntime_powerup;
			self.respawntimejitter = g_pickup_respawntimejitter_powerup;
		} else {
			self.respawntime = g_pickup_respawntime_weapon;
			self.respawntimejitter = g_pickup_respawntimejitter_weapon;
		}
	}
	e = weapon_info(wpn);
	self.weapons = e.weapons;
	self.weapons_extra = e.weapons_extra;
	if (e.items && e.items != IT_SUPERWEAPON) {
		if (!g_weapon_pickup_no_ammo || self.classname == "droppedweapon") {
			for (i = 0, j = 1; i < 24; ++i, j *= 2) {
				if (e.items & j) {
					ammofield = item_counter_field(j);
					if (ammofield) {
						if (self.count > 0)
							self.ammofield = self.count;
						else if (self.count < 0)
							self.ammofield = 999999;

						if (!self.ammofield)
							self.ammofield = cvar(strcat("g_pickup_", item_counter_field_name(j)));
					}
				}
			}
		}
	} else {
		self.flags |= FL_NO_WEAPON_STAY;
	}
	// weapon stay isn't supported for teamed weapons
	if (self.team)
		self.flags |= FL_NO_WEAPON_STAY;

	item_start(e.model, e.lodmodel1, "weapons/weaponpickup.wav", self.respawntime, self.respawntimejitter, e.message, 0, FL_WEAPON, weapon_pickupevalfunc, e.bot_pickupbasevalue);
	if not(item_start_failed)
	if (self.classname != "droppedweapon") {
		weapon_precache(e.weapon);
		self.enemy = weapon_spawn_chain;
		weapon_spawn_chain = self;
	}
}

// Setup weapon for client (after this raise frame will be launched)
void(float windex) weapon_setup {
	entity e;
	e = weapon_info(windex);
	self.items &= ~IT_AMMO;
	self.items = self.items | e.items;
	// the two weapon entities will notice this has changed and update their models
	self.weapon = windex;
	self.weaponname = e.mdl;
	self.ammoclip = 0;
	self.ammoclipmax = 0;
	weapon_action(windex, WEAPON_REQUEST_SETUP);
}

// perform weapon to attack (weaponstate and attack_finished check is here)
float(float secondary, float attacktime) weapon_prepareattack {
	if (!plugin_chain_WeaponPrepareAttack(secondary, attacktime)) {
		return FALSE;
	}
	if (attacktime >= 0) {
		// don't fire if previous attack is not finished
		if (WEAPON_ATTACK_FINISHED(self) > time)
			return FALSE;

		// don't fire while changing weapon
		if (self.weaponentity.state != WEAPON_STATE_READY)
			return FALSE;
	}
	// do not even think about shooting if switching
	if (self.switchweapon != self.weapon)
		return FALSE;

	if (timeout_status == 2) //don't allow the player to shoot while game is paused
		return FALSE;

	if not(player_can_fire(self, TRUE))
		return FALSE;

	if not(self.items & IT_UNLIMITED_WEAPON_AMMO)
	if not(weapon_ammo_check_secondary(self.weapon, secondary)) {
		if (akimbo_active(self) < 2) {
			float f = weapon_best(self);
			if (f == self.weapon) { //best failed
				f = weaypon_cycle_get(self, self.cvar_cl_weaponpriority, -1, -1, 0);
			}
			if (f > 0)
				weapon_switch_force(self, f);
		}
		return FALSE;
	}
	self.weaponentity.state = WEAPON_STATE_INUSE;
	// if the weapon hasn't been firing continuously, reset the timer
	if (attacktime >= 0) {
		if (WEAPON_ATTACK_FINISHED(self) <= self.ltime) {
			WEAPON_ATTACK_FINISHED(self) = time;
			//dprint("resetting attack finished to ", ftos(time), "\n");
		}
		WEAPON_ATTACK_FINISHED(self) = WEAPON_ATTACK_FINISHED(self) + attacktime * weapon_rate_factor();
	}
	return TRUE;
}

float(void) weapon_rate_factor {
	float t;
	entity oldself = self;
	self = akimbo_owner(self);
	t = (1.0 / g_weaponratefactor) * plugin_chain_weapon_rate_factor();
	self = oldself;
	return t;
}

float(entity o) weapon_rate_factor_for {
	entity oldself = self;
	self = o;
	float f = weapon_rate_factor();
	self = oldself;
	return f;
}

void(float fr, float t, void() func) weapon_thinkf {
	vector a = '0 0 0';
	vector of, or, ou;
	float restartanim;
	if (fr == WEAPON_FRAME_DONTCHANGE) {
		fr = self.weaponentity.wframe;
		restartanim = FALSE;
	} else if (fr == WEAPON_FRAME_IDLE)
		restartanim = FALSE;
	else
		restartanim = TRUE;

	of = v_forward;
	or = v_right;
	ou = v_up;
	if (self.weaponentity) {
		self.weaponentity.wframe = fr;
		if (sv_qcweaponanimation || fr >= WEAPON_FRAME_MELEE) {
			if (fr != WEAPON_FRAME_IDLE) {
				self.weapon_morph0time = time;
				self.weapon_morph0angles = self.weaponentity.angles;
				self.weapon_morph0origin = self.weaponentity.origin;
				self.weapon_morph1angles = '0 0 0';
				self.weapon_morph1time = time + t;
				makevectors(self.weapon_morph1angles_x * '-1 0 0' + self.weapon_morph1angles_y * '0 1 0' + self.weapon_morph1angles_z * '0 0 1');
				self.weapon_morph1origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
				self.weapon_morph2angles = '0 0 0';
				self.weapon_morph2time = time + t;
				makevectors(self.weapon_morph2angles_x * '-1 0 0' + self.weapon_morph2angles_y * '0 1 0' + self.weapon_morph2angles_z * '0 0 1');
				self.weapon_morph2origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
				self.weapon_morph3angles = '0 0 0';
				self.weapon_morph3time = time + t;
				makevectors(self.weapon_morph3angles_x * '-1 0 0' + self.weapon_morph3angles_y * '0 1 0' + self.weapon_morph3angles_z * '0 0 1');
				self.weapon_morph3origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
				self.weapon_morph4angles = '0 0 0';
				self.weapon_morph4time = time + t;
				makevectors(self.weapon_morph4angles_x * '-1 0 0' + self.weapon_morph4angles_y * '0 1 0' + self.weapon_morph4angles_z * '0 0 1');
				self.weapon_morph4origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
				if (fr == WEAPON_FRAME_FIRE1) {
					self.weapon_morph1angles = '5 0 0';
					self.weapon_morph1time = time + t * 0.1;
					makevectors(self.weapon_morph1angles_x * '-1 0 0' + self.weapon_morph1angles_y * '0 1 0' + self.weapon_morph1angles_z * '0 0 1');
					self.weapon_morph1origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
					self.weapon_morph4time = time + t + 1; // delay idle effect
				} else if (fr == WEAPON_FRAME_FIRE2) {
					self.weapon_morph1angles = '10 0 0';
					self.weapon_morph1time = time + t * 0.1;
					makevectors(self.weapon_morph1angles_x * '-1 0 0' + self.weapon_morph1angles_y * '0 1 0' + self.weapon_morph1angles_z * '0 0 1');
					self.weapon_morph1origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
					self.weapon_morph4time = time + t + 1; // delay idle effect
				} else if (fr == WEAPON_FRAME_RELOAD) {
					self.weapon_morph1time = time + t * 0.05;
					self.weapon_morph1angles = '-10 40 0';
					makevectors(self.weapon_morph1angles_x * '-1 0 0' + self.weapon_morph1angles_y * '0 1 0' + self.weapon_morph1angles_z * '0 0 1');
					self.weapon_morph1origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);

					self.weapon_morph2time = time + t * 0.15;
					self.weapon_morph2angles = '-10 40 5';
					makevectors(self.weapon_morph2angles_x * '-1 0 0' + self.weapon_morph2angles_y * '0 1 0' + self.weapon_morph2angles_z * '0 0 1');
					self.weapon_morph2origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);

					self.weapon_morph3time = time + t * 0.25;
					self.weapon_morph3angles = '-10 40 0';
					makevectors(self.weapon_morph3angles_x * '-1 0 0' + self.weapon_morph3angles_y * '0 1 0' + self.weapon_morph3angles_z * '0 0 1');
					self.weapon_morph3origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity);
				} else if (fr == WEAPON_FRAME_MELEE) {
					self.weapon_morph1time = time + t * 0.25;
					self.weapon_morph1angles = sv_qcanimation_melee_morph1angles;
					makevectors(self.weapon_morph1angles_x * '-1 0 0' + self.weapon_morph1angles_y * '0 1 0' + self.weapon_morph1angles_z * '0 0 1');
					self.weapon_morph1origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity) + sv_qcanimation_melee_morph1origin;

					self.weapon_morph2time = time + t * 0.65;
					self.weapon_morph2angles = sv_qcanimation_melee_morph2angles;
					makevectors(self.weapon_morph2angles_x * '-1 0 0' + self.weapon_morph2angles_y * '0 1 0' + self.weapon_morph2angles_z * '0 0 1');
					self.weapon_morph2origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity) + sv_qcanimation_melee_morph2origin;
				} else if (fr == WEAPON_FRAME_MELEE2) {
					self.weapon_morph1time = time + t * 0.25;
					self.weapon_morph1angles = sv_qcanimation_melee2_morph1angles;
					makevectors(self.weapon_morph1angles_x * '-1 0 0' + self.weapon_morph1angles_y * '0 1 0' + self.weapon_morph1angles_z * '0 0 1');
					self.weapon_morph1origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity) + sv_qcanimation_melee2_morph1origin;
					self.weapon_morph2time = time + t * 0.65;
					self.weapon_morph2angles = sv_qcanimation_melee2_morph2angles;
					makevectors(self.weapon_morph2angles_x * '-1 0 0' + self.weapon_morph2angles_y * '0 1 0' + self.weapon_morph2angles_z * '0 0 1');
					self.weapon_morph2origin = QCWEAPONANIMATION_ORIGIN(self.weaponentity) + sv_qcanimation_melee2_morph2origin;
				}
			}
		} else {
			if (fr == WEAPON_FRAME_IDLE)
				a = self.weaponentity.anim_idle;
			else if (fr == WEAPON_FRAME_FIRE1)
				a = self.weaponentity.anim_fire1;
			else if (fr == WEAPON_FRAME_FIRE2)
				a = self.weaponentity.anim_fire2;
			else if (fr == WEAPON_FRAME_RELOAD)
				a = self.weaponentity.anim_reload;

			a_z *= g_weaponratefactor;
			anim_set(self.weaponentity, a, restartanim == FALSE, restartanim, restartanim);
		}
		if (self.weaponentity.weaponentity)
			self.weaponentity.weaponentity.frame = self.weaponentity.frame + 1;
	}
	v_forward = of;
	v_right = or;
	v_up = ou;
	if (self.weapon_think == weapon_ready && func != weapon_ready && self.weaponentity.state == WEAPON_STATE_RAISE) {
		backtrace("Tried to override initial weapon think function - should this really happen?");
	}
	t *= weapon_rate_factor();
	// VorteX: haste can be added here
	if (self.weapon_think == weapon_ready) {
		self.weapon_nextthink = time;
		//dprint("started firing at ", ftos(time), "\n");
	}
	if (self.weapon_nextthink < time - frametime * 1.5 || self.weapon_nextthink > time + frametime * 1.5) {
		self.weapon_nextthink = time;
		//dprint("reset weapon animation timer at ", ftos(time), "\n");
	}
	self.weapon_nextthink = self.weapon_nextthink + t;
	self.weapon_think = func;
	//dprint("next ", ftos(self.weapon_nextthink), "\n");
	if (restartanim)
	if (t)
	if (!self.crouch || self.body.weaponentity) { // shoot anim stands up, this looks bad
		if (fr == WEAPON_FRAME_MELEE2)
			anim_set(self.body, self.anim_melee2, FALSE, TRUE, TRUE);
		else if (fr == WEAPON_FRAME_MELEE || plugin_chain_weapon_animation_is_melee(fr)) {
			player_body_animation_set(self, anim_melee, FALSE, TRUE, TRUE, 1);
			if (self.body)
				self.body.animstate_endtime = time + t;

			if (fr != WEAPON_FRAME_MELEE) {
				self.weapon_morph0time = time;
				self.weapon_morph1time = time + t * 0.25;
				self.weapon_morph2time = time + t * 0.65;
			}
		} else
			player_body_animation_set(self, anim_shoot, FALSE, TRUE, TRUE, 1);

		if (self.body.weaponentity)
		if (self.crouch)
			player_body_animation_set(self, anim_duckidle, FALSE, TRUE, TRUE, 2);
	}
}

// Weapon subs
void(void) weapon_clear {
	if (self.weapon != -1)
		self.weapon = 0;

	if (self.weaponentity) {
		if (self.weapon || self.switchweapon)
			self.weaponentity.state = WEAPON_STATE_CLEAR;
		else
			self.weaponentity.state = WEAPON_STATE_READY;

		self.weaponentity.effects = 0;
	}
}

void(void) weapon_ready {
	if (self.weaponentity)
		self.weaponentity.state = WEAPON_STATE_READY;

	weapon_thinkf(WEAPON_FRAME_IDLE, 1000000, weapon_ready);
}

// this function calculates weapon_shotorg and weapon_shotdir based on the weapon model
// offset, trueaim and antilag, and won't put weapon_shotorg inside a wall.
// make sure you call makevectors first (FIXME?)
void(entity ent, vector s_forward, float recoil, string snd, float maxhits) weapon_setup_shotdir {
	vector vecs, vecs_visual, dv;
	entity ent_orig = ent;
	ent = akimbo_owner(ent);
	// Track max damage and set the stat to be sent later in g_world.qc
	if (maxhits > 0)
		weapon_score_fires(ent, ent.weapon, maxhits);

	if (ent_orig.weaponentity.movedir_x > 0) {
		vecs = ent_orig.weaponentity.movedir;
		vecs_y = -vecs_y;
	} else
		vecs = '0 0 0';

	vecs_visual = ent_orig.weaponentity.shotorg_visual;
	vecs_visual_y = -vecs_visual_y;
	dv = v_right * vecs_y + v_up * vecs_z;
	vector o = ent.origin + ent.view_ofs;
	weapon_shotorg = o + v_forward * g_shootforward;
	weapon_shotorg_visual = weapon_shotorg + (v_right * vecs_visual_y + v_up * vecs_visual_z) + v_forward * 48;
	weapon_shotorg = weapon_shotorg + dv;
	trace_line(o, weapon_shotorg, TRACE_MOVE_NORMAL, ent);
	if (trace_fraction < 1) {
		weapon_shotorg = trace_endpos + normalize(o - trace_endpos);
	}
	// calculate the shotdir from the chosen shotorg
	if (!g_norecoil) {
		if (g_recoil_extra && !g_topview && !g_sideview) {
			vector a = vectoangles(s_forward + randomvec() * g_recoil_extra_spread *
					((ent.flags & FL_ONGROUND) ? (ent.crouch ? g_recoil_extra_spread_crouch_factor : 1) : g_recoil_extra_spread_fly_factor) * ent.punchangle_x);
			a_x = -a_x;
			makevectors(a + ent.punchangle_x * '1 0 0');
			s_forward = v_forward;
			float f = max(0, 1 - fabs(sin(ent.punchangle_x * MATH_DEG2RAD)));
			ent.punchangle_x -= recoil * f * g_recoil_extra *
					((ent.flags & FL_ONGROUND) ? (ent.crouch ? g_recoil_extra_crouch_factor : 1) : g_recoil_extra_fly_factor);
		} else
			ent.punchangle_x = min(ent.punchangle_x, recoil * -1);
	}
	if (akimbo_active(ent) || vecs == '0 0 0')
		weapon_shotdir = s_forward;
	else {
		float dphitcontentsmask_save = ent.dphitcontentsmask;
		ent.dphitcontentsmask = DPCONTENTS_SOLID | DPCONTENTS_BODY | DPCONTENTS_CORPSE;
		warpzone_trace_line(o, o + s_forward * WORLD_MAX_SHOT_DISTANCE, TRACE_MOVE_NOMONSTERS, ent);
		ent.dphitcontentsmask = dphitcontentsmask_save;
		weapon_shotpoint = warpzone_untransform_origin(warpzone_trace_transform, trace_endpos);
		weapon_shotdir = normalize(weapon_shotpoint - weapon_shotorg);
	}
	if (ent.lastshot_time < time) {
		if (snd != "")
			sound (ent, CHAN_WEAPON, snd, VOL_BASE, ATTN_NORM);

		if (ent.items & IT_STRENGTH)
			sound (ent, CHAN_AUTO, "weapons/strength_fire.wav", VOL_BASE, ATTN_NORM);

		ent.lastshot_time = time;
	}
}

void(float r) weapon_shake {
	if not(g_norecoil)
	if not(g_recoil_extra)
		self.punchangle = self.punchangle + '1 0 0' * r * (random() - 0.5) + '0 1 0' * r * (random() - 0.5);
}

vector(vector pvelocity, vector mvelocity) weapon_calculate_projectile_velocity {
	vector mdirection;
	float mspeed;
	float outspeed;
	vector outvelocity = '0 0 0';
	mvelocity = mvelocity * g_weaponspeedfactor;
	mdirection = normalize(mvelocity);
	mspeed = vlen(mvelocity);
	if (g_projectiles_newton_style == 0) {
		// absolute velocity
		outvelocity = mvelocity;
	} else if (g_projectiles_newton_style == 1) {
		// true Newtonian projectiles
		outvelocity = pvelocity + mvelocity;
	} else if (g_projectiles_newton_style == 2) {
		float pcos = pvelocity * mdirection;
		float pspeed = vlen(pvelocity);
		outspeed = pcos + sqrt(max(0, mspeed * mspeed - pspeed * pspeed + pcos * pcos));
		outspeed = bound(mspeed * g_projectiles_newton_style_2_minfactor, outspeed, mspeed * g_projectiles_newton_style_2_maxfactor);
		outvelocity = mdirection * outspeed;
	} else if (g_projectiles_newton_style == 3) {
		outspeed = mspeed + mdirection * pvelocity;
		outspeed = bound(mspeed * g_projectiles_newton_style_2_minfactor, outspeed, mspeed * g_projectiles_newton_style_2_maxfactor);
		outvelocity = mdirection * outspeed;
	} else
		outvelocity = mvelocity;

	return outvelocity;
}

vector(vector vecs, float y_is_right, float allowcenter) weapon_shotorg_adjustfromclient {
	switch(self.owner.cvar_cl_gunalign & 7) {
	case 1: // right
		break;
	case 2: // left
		vecs_y = -vecs_y;
		break;
	default:
	case 3:
		if (allowcenter) { // 2: allow center handedness
			// center
			vecs_y = 0;
			vecs_z -= 4;
		} else {
			// right
		}
		break;
	case 4:
		if (allowcenter) {// 2: allow center handedness
			// center
			vecs_y = 0;
			vecs_z -= 4;
		} else {
			// left
			vecs_y = -vecs_y;
		}
		break;
	}
	return vecs;
}

vector(vector vecs, float y_is_right, float visual, float _akimbo_active) weapon_shotorg_adjust {
	if (_akimbo_active) {
		if (_akimbo_active == 2)
			vecs_y = -vecs_y;
		else if (_akimbo_active == 3)
			vecs_y = 0;

		if not(visual) {
			if (g_shootfromeye)
				vecs_z = 0;
			else if (g_shootfromcenter)
				vecs_z -= 4;
		}
		vecs_y = vecs_y * 1.2;
		return vecs;
	}
	if (g_shootfromeye) {
		if (visual) {
			vecs = weapon_shotorg_adjustfromclient(vecs, y_is_right, TRUE);
		} else {
			vecs_y = 0;
			vecs_z = 0;
		}
	} else if (g_shootfromcenter) {
		if (visual) {
			vecs = weapon_shotorg_adjustfromclient(vecs, y_is_right, TRUE);
		} else {
			vecs_y = 0;
			vecs_z -= 4;
		}
	} else {
		if (visual)
			vecs = weapon_shotorg_adjustfromclient(vecs, y_is_right, self.owner.cvar_cl_gunalign & 8);
	}
	return vecs;
}

void(entity missile) weapon_setup_projectile_velocity {
	if not(missile.owner)
		error("Unowned missile");

	missile.velocity = weapon_calculate_projectile_velocity(missile.owner.velocity, missile.velocity);
	if not(missile.gravity)
	if (missile.movetype == MOVETYPE_TOSS || missile.movetype == MOVETYPE_BOUNCE)
		missile.gravity = 1;
}

void(entity flash, vector offset) weapon_attach_to_shotorg {
	entity xflash;
	flash.owner = self;
	flash.angles_z = random() * 360;
	if (sv_qcweaponanimation) {
		setorigin(flash, weapon_shotorg + weapon_shotdir * 50);
		flash.angles = vectoangles(weapon_shotdir);
		flash.angles_z = random() * 360;
	} else {
		weapon_setattachment(flash, self.weaponentity, "shot");
		setorigin(flash, offset);
		xflash = spawn();
		copyentity(flash, xflash);
		flash.viewmodelforclient = akimbo_owner(self);
		if (self.weaponentity.oldorigin_x > 0) {
			setattachment(xflash, self.exteriorweaponentity, "");
			setorigin(xflash, self.weaponentity.oldorigin + offset);
		} else {
			weapon_setattachment(xflash, self.exteriorweaponentity, "shot");
		}
	}
}

void(entity e, float wep, string name) weapon_give {
	entity oldself;
	if (!wep)
		return;

	entity wi = weapon_info(wep);
	e.weapons = e.weapons | wi.weapons;
	e.weapons_extra = e.weapons_extra | wi.weapons_extra;
	oldself = self;
	self = e;
	if (other.classname == "player") {
		weapon_show_list(other);
		if (clienttype(other) == CLIENTTYPE_REAL)
			print_to(other, PRINT_INFO, "You got the ^2{1}", name, "", "");
	}
	self = oldself;
}

void(void) weapon_priority_update {
	str_unzone_ifneeded(weapon_priority_by_order);
	str_unzone_ifneeded(weapon_priority_by_impulse);
	weapon_priority_by_order = "";
	entity wi;
	WEAPON_INFO_FOR_EACH(wi)
		weapon_priority_by_order = strcat(weapon_priority_by_order, " ", ftos(wi.weapon));

	float imp;
	weapon_priority_by_impulse = "";
	WEAPON_INFO_FOR_EACH(wi)
		if (wi.impulse == 0)
			weapon_priority_by_impulse = strcat(weapon_priority_by_impulse, " ", ftos(wi.weapon));

	for (imp = 9; imp > 0; --imp)
		WEAPON_INFO_FOR_EACH(wi)
			if (wi.impulse == imp)
				weapon_priority_by_impulse = strcat(weapon_priority_by_impulse, " ", ftos(wi.weapon));

	weapon_priority_by_order = strzone(substring(weapon_priority_by_order, 1, strlen(weapon_priority_by_order) - 1));
	weapon_priority_by_impulse = strzone(substring(weapon_priority_by_impulse, 1, strlen(weapon_priority_by_impulse) - 1));
}

float(float wr) weapon_dummy_func {
	return 0;
}

void(float id,
		float(float) func,
		float ammotype,
		float i,
		float normalweapon, float canclimb, float pickupbasevalue,
		string modelname, string shortname, string wname) weapon_register {
	entity e = weapon_register_common(id, i, shortname, wname);
	str_unzone_ifneeded(e.model);
	str_unzone_ifneeded(e.mdl);
	str_unzone_ifneeded(e.model2);
	e.weapon_func = func;
	e.items = ammotype;
	string s = cvar_string(strcat("sv_model_", modelname));
	if (s == "")
		s = modelname;
	else
		dlc_add_dlc_or_pk3_by_file(s);

	e.model = strzone(strcat("models/weapons/g_", s, ".md3"));
	e.mdl = strzone(s);
	e.lodmodel1 = strzone(strcat("models/weapons/g_", modelname, ".md3"));
	float animfile;
	string animfilename = strcat("models/weapons/h_", e.mdl, ".dpm.animinfo");
	animfile = fopen(animfilename, FILE_READ);
	// preset some defaults that work great for renamed zym files (which don't need an animinfo)
	e.anim_fire1  = '0 1 0.01';
	e.anim_fire2  = '1 1 0.01';
	e.anim_idle   = '2 1 0.01';
	e.anim_reload = '3 1 0.01';
	if (animfile >= 0) {
		anim_parseerror = FALSE;
		anim_parseline(e, animfile, anim_fire1);
		anim_parseline(e, animfile, anim_fire2);
		anim_parseline(e, animfile, anim_idle);
		anim_parseline(e, animfile, anim_reload);
		fclose(animfile);
		if (anim_parseerror)
			print("Parse error in ", animfilename, ", some animations are broken\n");
	}
	e.model2 = strzone(strcat("wpn-", e.mdl));
	e.spawnflags = 0;
	if (normalweapon > 0)
		e.spawnflags |= WEAPON_FLAG_NORMAL;

	if (normalweapon < 0)
		e.spawnflags |= WEAPON_FLAG_HIDDEN;

	if (canclimb)
		e.spawnflags |= WEAPON_FLAG_CANCLIMB;

	e.bot_pickupbasevalue = pickupbasevalue;
}

void(void) weapon_init {
	float i;
	CVAR_CACHE(g_balance_weaponswitchdelay);
	CVAR_CACHE(g_projectiles_newton_style_2_minfactor);
	CVAR_CACHE(g_projectiles_newton_style_2_maxfactor);
	CVAR_CACHE(sv_qcweaponanimation);
	CVAR_CACHE(g_weaponspeedfactor);
	CVAR_CACHE(g_weaponratefactor);
	CVAR_CACHE(g_shootfromcenter);
	CVAR_CACHE(g_shootfromeye);
	CVAR_CACHE(g_shootforward);
	CVAR_CACHE(g_projectiles_newton_style);
	CVAR_CACHE(g_norecoil);
	CVAR_CACHE(g_recoil_extra);
	CVAR_CACHE(g_recoil_extra_crouch_factor);
	CVAR_CACHE(g_recoil_extra_fly_factor);
	CVAR_CACHE(g_recoil_extra_spread);
	CVAR_CACHE(g_recoil_extra_spread_crouch_factor);
	CVAR_CACHE(g_recoil_extra_spread_fly_factor);
	CVAR_CACHE(g_weapon_throw_mode);
	CVAR_CACHE(g_weapon_throw_noammo);
	CVAR_CACHE(g_weapon_thrown_lifetime);
	CVAR_CACHE(g_weapon_pickup_no_ammo);
	CVAR_CACHE(g_weapon_switch_to_empty);
	CVAR_CACHE(g_showweaponspawns);
	CVAR_CACHE(sv_debug_weapon_tags);
	sv_qcanimation_melee_morph1angles = stov(cvar_string("sv_qcanimation_melee_morph1angles"));
	sv_qcanimation_melee_morph2angles = stov(cvar_string("sv_qcanimation_melee_morph2angles"));
	sv_qcanimation_melee_morph1origin = stov(cvar_string("sv_qcanimation_melee_morph1origin"));
	sv_qcanimation_melee_morph2origin = stov(cvar_string("sv_qcanimation_melee_morph2origin"));
	sv_qcanimation_melee2_morph1angles = stov(cvar_string("sv_qcanimation_melee2_morph1angles"));
	sv_qcanimation_melee2_morph2angles = stov(cvar_string("sv_qcanimation_melee2_morph2angles"));
	sv_qcanimation_melee2_morph1origin = stov(cvar_string("sv_qcanimation_melee2_morph1origin"));
	sv_qcanimation_melee2_morph2origin = stov(cvar_string("sv_qcanimation_melee2_morph2origin"));
	sv_qcanimation_melee_exterior = stov(cvar_string("sv_qcanimation_melee_exterior"));
	entity e = self;
	WEAPON_INFO_FOR_EACH(self) {
		self.weapon_func(WEAPON_REQUEST_CVAR_CACHE);
	}
	self = e;
	weapon_melee_init();
	bullet_init();
	projectile_register_auto(PROJECTILE_BULLET, '0 0 0');
	projectile_register_auto(PROJECTILE_BULLET_GLOWING, '0 0 0');
	projectile_register_auto(PROJECTILE_BULLET_BIG, '0 0 0');
}
